---
article: true
title: Leetcode
icon: read
---

## 思路

- 双指针与链表
    - 合并有序链表
    - 拆分链表
    
        直接使用两个节点遍历，按条件分别生成两个链表，最后合并起来，注意中途要拆分原有的关联
    - 合并k个有序链表

        类似合并2个有序链表，但这里使用到了优先级队列，快速找到最小的节点。优先级队列属于单独的数据结构，需要了解
    - 单链表的倒数第 k 个节点

        两个指针，第一个先走k步，再将两个指针一起走，最后第一个指针到达尾部时，第二个刚好走了n-k步
        类似的还有删除倒数第k个节点
    - 链表中点

        直接使用快慢指针
    - 判断是否包含环
        
        使用快慢指针，如果两个指针相交则表示包含环，相交后任意一个节点回到头，然后相同速度往前走，再次相交则为相交的起点。
    - 两个链表是否相交

        两个指针分别依次走两个链表，最后看是否相交。
        类似的，也可以将两个链表首位相连，判断是否存在环

- 双指针与数组
    - 快慢指针
        - 原地修改数组

            删除排序数组中的重复元素等，直接使用快慢指针，发现一个与慢指针不同的时，将慢指针设置为新值，这样从0到慢指针就都为不同的元素了。
    - 左右指针
        - 二分查找

            二分查找是一种左右指针的应用
        - 两数之和，但是是有序数组

            一左一右指针，相加和，如果结果大了则右边往左，结果小了则左边往右，如果指针相遇则没有结果
        - 翻转数组

            一左一右互换即可
        - 判断回文

            一左一右判断是否相等，一直持续到指针相遇。
            判断最长回文子串，也就是从中间开始向两边试图查找回文串，注意中心可能是当前字符，也可能是当前和接下来的字符

- 动态规划法

    核心思想在于找到分解问题，将问题降级再重新组装
    斐波那契数列：分解为前面2个数之和
    最长递增自学：当前序列是否为递增，新增下一个值是否依然为递增

- 回溯法

    代码框架
```
    result = []
def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return
    
    for 选择 in 选择列表:
        做选择
        backtrack(路径, 选择列表)
        撤销选择
```
    回溯法本身不难，关键还是要多写

- BFS

```java
    // 计算从起点 start 到终点 target 的最近距离
int BFS(Node start, Node target) {
    Queue<Node> q; // 核心数据结构
    Set<Node> visited; // 避免走回头路
    
    q.offer(start); // 将起点加入队列
    visited.add(start);

    while (q not empty) {
        int sz = q.size();
        /* 将当前队列中的所有节点向四周扩散 */
        for (int i = 0; i < sz; i++) {
            Node cur = q.poll();
            /* 划重点：这里判断是否到达终点 */
            if (cur is target)
                return step;
            /* 将 cur 的相邻节点加入队列 */
            for (Node x : cur.adj()) {
                if (x not in visited) {
                    q.offer(x);
                    visited.add(x);
                }
            }
        }
    }
    // 如果走到这里，说明在图中没有找到目标节点
}
```
    多写

- 二分搜索

    最重要还是细节

- 滑动窗口算法

```c++
int left = 0, right = 0;

while (left < right && right < s.size()) {
    // 增大窗口
    window.add(s[right]);
    right++;
    
    while (window needs shrink) {
        // 缩小窗口
        window.remove(s[left]);
        left++;
    }
}
```

- n数之和

    依然是将数组排序，左右指针互博。如果要获取大于2的结果，例如3数之和，则将一个数取出，计算剩下数组的n-k结果。



## 核心思路
### 基础数据结构
#### 数组/链表
-   数组思路：前缀和
    
    将数组转换为前缀和，可以方便的计算某一段的和，也可以用于二维数组，计算范围的和
-   数组思路：差分数组
    
    差分数组是前缀和的逆运算，可以用于区间加法，航班预订等问题。
    差分数组的特点是，可以方便的一个数组批量的进行操作，当我们为一个数组区间进行增加或减小时，可以为仅操作差分数组区间的第一个与最后一个。再恢复为原有的数组。
-   滑动窗口法

    滑动窗口是一种非常常用的算法思路，可以用来解决子串等问题。
    与滑动窗口类似的还有快慢指针，左右指针，都是通过两个指针对链表进行操作。
    一个简单的滑动窗口算法可以是这样

```c++
/*滑动窗口算法框架*/
void slidingWindow(string s, string t) { 
    unordered_map<char, int> need, window;
    for (char c : t) need[c]++;
    int left = 0, right = 0;
    int valid = 0;
    while (right < s.size()) {
        char c = s[right]; // c是将移入窗口的字符
        // right++; 右移窗口
        //  进行窗口内数据的更新
        // ...
        printf("window: [%d, %d)\n", left, right); /*** debug ***/
        while (window needs shrink) { //判断左侧窗口是否要收缩
            char d = s[left]; // d是将移出窗口的字符
            // left++; 左移窗口
            //...进行窗口内数据的更新
        }
    }
}
```

-   有序数组二分搜索
-   原地修改数组
-   单链表
    - 链表合并，链表分割
    - 链表倒数第k个节点
    - 链表中点，是否有环
    - 两个链表是否相交
-   递归操作链表
#### 队列/栈
-   队列和栈相互实现
-   括号匹配问题

#### 数据结构设计
-   LRU算法
-   LFU算法
-   查找/删除数组中任意元素

### 进阶数据结构
#### 二叉树
#### 二叉搜索树
#### 图
### 暴力算法
-   DFS/回溯算法
-   BFS算法
### 动态规划
#### 经典动态规划
#### 背包问题